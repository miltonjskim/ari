# Today I Learned

## 목차

- [Week 1 (2025-03-03 ~ 2025-03-07)](#week-1-2025-03-03---2025-03-07)
- [Week 2 (2025-03-10 ~ 2025-03-14)](#week-2-2025-03-10---2025-03-14)

---

## Week 1 (2025-03-03 ~ 2025-03-07)

<details>
<summary>2025-03-04 TUE</summary>

### useState

props를 부모에게 받았을 경우 자식 컴포넌트는 무조건 리렌더링됨. (state가 변경되지 않아도 리렌더링이 될수도 있음)

**리액트 리렌더링 조건**
>1. state 변경 시 리렌더링
>2. props 변경 시 리렌더링
>3. 부모 컴포넌트 리렌더링 발생 시 자식 컴포넌트 리렌더링

부모 컴포넌트 리렌더링 발생 시 모든 자식 컴포넌트도 리렌더링되는 것은 부하가 될 수 있다.

~~그러므로 props로 연결된 부분을 없애고 하위 컴포넌트에서 정의를 하는게 나을 수 있다.~~

⇒ 이런 경우 useMemo훅, useCallback, React.memo을 사용해 캐싱할 수 있다.

**setState의 활용**

state의 set 상태변화함수는 상태를 함수를 활용해 변경하는 역할을 한다. onChange나 onClick같은 이벤트리스너와 조합하면 사용자 입력에 따라 상태를 변경하는 기능을 만들 수 있다.

++ state 변수에는 객체도 등록이 가능함. 이를 통해 여러개의 state 변수를 관리하는 것보다 안전하게 관리가 가능함.

상태 변경 시에 다른 부분은 그대로 유지하고 한 부분만 변경하도록하여 적용한다.

- 스프레드 연산자 : …객체명을 통해 객체의 요소들을 한번에 표현할 수 있다.
- 자바스크립트의 문법으로 객체 속성에 동적으로 접근할 때 [벼]

### useMemo

useMemo 훅은 정의한 함수의 의존성 배열 값이 변경되지 않는 경우 이전 실행 결과를 재사용한다. 그래서 특정 컴포넌트의 리렌더링을 막을 수 있다. 

**단, useMemo는 메모리 사용량 증가로 이어지며 성능이 떨어질수도 있다.** 

**또한 메모이제이션 값이 너무 많아지면 관리가 어렵다.** 

### useCallback

useCallback 훅은 함수를 메모이제이션한다. 특정 함수의 실행 결과를 재사용한다.

### 의존성 배열

- 불필요한 재실행을 막고 싶다면 꼭 필요한 값만 의존성 배열에 넣어야 한다.
- 빈 배열을 넣으면 최초 1회만 실행됨. 그 이후로는 변경되는 값이 없기 때문에 다시 실행되지 않음.
- 의존성 배열을 생략하면 useMemo, useEffect 등의 훅이 매번 실행됨 → 최적화 효과가 없음

### useEffect와 useMemo

| Hook | 사용 목적 | 실행 시점 | 반환 값 | 주의할 점 |
| --- | --- | --- | --- | --- |
| `useEffect` | 부수 효과 (Side Effects) 처리 | 렌더링 후 (After Render) 실행 | `undefined` (리턴값 없음) | 비동기 작업, DOM 조작 등에 사용 |
| `useMemo` | 값(Value) 메모이제이션 | 렌더링 중 (During Render) 실행 | 캐싱된 값(Value) | 연산이 무거운 경우에만 사용해야 성능 최적화됨 |

useMemo는 렌더링 도중 실행되며 비동기 작업 불가능

```
💡 useMemo 프로세스

의존성 배열에 있는 값이 변경 → 컴포넌트가 다시 렌더링 → 그 렌더링 과정 중에 useMemo가 실행
```

### useRef

이전 값과 새로운 값을 연결하고, 렌더링과는 무관하게 값이 유지되어야 할 때 사용됨.

```tsx
const a = useRef(초기값); // ref 객체 선언
a.current // ref 객체의 상태 조회
```

리렌더링을 해도 ref객체의 상태는 유지되고 ref객체의 상태가 변해도 렌더링이 발생하지 않는다는 특징을 갖고 있다.

## 번외

### 타입스크립트의 type guard

이전까지 타입스크립트를 사용하면서 `any` 만 안쓰면 되겠지 하며 assertion type 일명 `as` 키워드를 자주 사용해왔다. 그 이유는 null이 올 수 있더라도 변수의 타입이 string 타입이라는 개인적인? 확신이 있었기 때문이다. 

JS에서는 타입 좁히기(type narrowing)가 타입을 더 쉽게 예측할 수 있는 작업이었고, `as` 키워드 또한 type narrowing 중 하나의 수단이라고 생각했다. 

그런데 공부하다보니 이 `as` 의 타입 확정은 오히려 타입스크립트의 타입 검사 기능을 포기하겠다는 것이나 다름없다고 한다. 그 이유는 개발자가 변수에 어떤 타입이 올지 확실히 인지했다 하여도 `as` 선언에서 실수를 한다면 런타임에러가 터지기 전까지 인지할 수 없기 때문이다.

그 이유는 다음과 같다.

1. 자신은 반드시 string 타입이 올 것이라 생각해 as string을 작성함.
2. 하지만 그것은 개발자의 착각일 가능성이 있거나 요구사항 변경에 따라 변하게 될 가능성이 있음
3. 그렇게 컴파일 시점을 자연스럽게 통과하더라도 런타임에서 오류가 터질 수 있음

비유하자면 이러한 방식은 컴파일러에게 “내가 이 타입을 너보다 더 잘알고있음. 믿어주셈 ㅇㅇ” 라고 말하는 것과 같다. 어림도 없다.

### **결론**

as보다 type narrowing의 올바른 기법은 null 체크 혹은 typeof나 instanceof를 사용한 type guard 기법이다. 이러한 type guard 기법은 무조건 타입을 확정짓는 as와 달리 `타입 검사를 통과하면 타입이 확정` 되기 때문에 옳은 방식이다.

### 자바의 instanceof

> </br>  
> typeof나 instanceof를 사용한 type narrowing은 자바에서는 지양해야 한다. 왜냐하면 instanceof 체크가 필요한 부분이 있다면 그 부분은 객체지향적으로 분리가 필요한 부분일 가능성이 높기 때문이다.
> 
> 1. OCP 위반 : 새로운 타입이 추가될 때마다 instanceof 체크를 변경해야 함.
> 2. TDA(tell don’t ask) 위반: 데이터를 요구하지 않고 객체가 자연스럽게 상호작용하도록해야함. 데이터를 요구하는 행위는 두 함수의 데이터 결합이 이뤄졌다는 뜻임
> 3. 다형성 위반 : instanceof 체크는 강제로 그 타입인 상태일 때의 행동을 규정하므로 미리 설정해둔 동작을 벗어난 동작을 함.
> </br>
</details>

---

## Week 2 (2025-03-10 ~ 2025-03-14)
