<details>
<summary>3월 4일</summary>
<div markdown="1">

### 스마트 컨트랙트란?
- 스마트 컨트랙트는 계약 당사자 간의 거래 내용을 코드로 기록해 두고 블록체인에 올려두면,
이후 계약 조건이 충족되었을 때 계약을 자동으로 이행해주는 시스템이다. 
- 이를 통해 은행처럼 계약 이행을 검증, 보증하는 중앙하된 시스템이 없어도 자동으로 계약을 이행할 수 있어 편리성과 경제성을 갖췄다.

### 스마트 컨트랙트, 어떻게 동작하는가?
- 계약 내용은 스마트 컨트랙트 소스코드로 작성되어 블록체인 네트워크에 전송된다.
- 네트워크 참여자들의 유효성 검증이 이루어진 후 검증 완료 시 해당 스마트 컨트랙트가 포함된 블록이 생성되어 배포된다.
- 이후 블록체인은 스마트 컨트랙트가 담긴 블록의 변경 상태를 지속적으로 확인한다. 조건에 따른 상태 변경 시 명령 실행 비용을 계산하고 상태 변경 트랜잭션을 생성한다.

### 스마트 컨트랙트의 장점
1. 자율성
    - 블록체인 내에서 진행되기 때문에 공신력을 가진 제 3자 또는 기관이 필요하지 않아, 거래 당사자들이 계약에 대한 온전한 권한, 통제를 갖게 된다.
2. 비용 절감
    - 블록체인에서 관련 계약, 거래 내역 등을 보증할 수 있는 제 3자나 공신력을 가진 기관을 필요로 하지 않아 비용 절감의 효과를 갖는다.
3. 신뢰성
    - 블록체인 내 스마트 컨트랙트에 의해 계약이 공정하게 진행되며, 문서의 위변조가 극히 어렵기 때문에 신뢰성이 뛰어나다.
4. 보안성
    - 문서가 암호화되어 블록체인 내 분산 원장 기술에 의헤 안전하게 보관된다.
</div>
</details>

<details>
<summary>3월 5일</summary>
<div markdown="1">

### 블록체인 구조
블록체인을 이루고 있는 블록 하나하나의 구조는 어떻게 구성되어 있을까?
블록 하나는 헤더와 바디로 나누어져 있으며, 헤더는 메타 데이터, 바디는 트랜잭션 리스트로 구성되어 있다.

### 블록체인 트랜잭션
블록체인 네트워크는 하나의 커다란 데이터베이스로, 블록체인 내 트랜잭션 역시 다른 데이터베이스와 마찬가지로 트랜잭션의 안정성을 보장하기 위한 ACID성질을 가지고 있다.

### 이더리움 트랜잭션 구조
- 논스 : 트랜잭션 발신 EOA에 의해 발행되어 트랜잭션 메시지 재사용을 방지하는데 사용되는 일련번호
- 가스 가격 : 발신자가 지급하는 가스(수수료)의 가격으로 이더리움의 가장 작은 단위인 웨이(wei)단위로 기록
- 가스 한도 : 발신하는 트랜잭션을 위해 사용할 가스의 최대치로, 한도를 넘는 가스비가 사용된다면 트랜잭션 실패
- 수신자 : 이 트랜잭션을 받는, 트랜잭션의 목적지 이더리움 주소
- 값 : 목적지에 보낼 이더리움 코인의 양
- 데이터 : 가변 길이 바이너리 데이터 페이로드로, 스마트 컨트랙트 호출 시 사용
- v,r,s : EOA의 ECDSA 디지털 서명의 세 가지 구성 요소소
</div>
</details>

<details>
<summary>3월 6일</summary>
<div markdown="1">

### 온체인과 오프체인
- 온체인(on-chain) : 온체인은 말 그대로 거래가 블록체인 위에 기록된다. 블록체인은 여러 사람이 같은 데이터를 동시에 유지함으로써 특정 세력의 악의적인 정보 위변조를 막을 수 있다. 그렇기 때문에 블록체인의 핵심 속성 중 하나는 '낙장불입'이다. 예를 들어 A가 자신의 비트코인 주소에서 B의 비트코인 주소로 1BTC를 직접 송금했다면, 이는 온체인 거래에 해당하며 채굴자들의 검증을 거쳐 변할 수 없는 '사실'로 확정되는 것이다.

- 오프체인(off-chain) : 블록체인 밖에서 이루어진 행위로서, 블록체인에서 오프체인 거래가 필요한 경우도 여럿있다. 거래 처리 속도가 느린 비트코인의 경우 많은 사람이 일으키는 모든 거래를 감당하기 힘들어 일상적인 거래활동에 사용되기에는 무리가 따른다. 이에 '라이트닝 네트워크'라는 기술을 도입해 모든 거래를 비트코인 블록체인 밖에서 모아 처리하고 겨로가만 블록체인 위에 기록하는 레이어2 솔루션을 이용한다.

</div>
</details>

<details>
<summary>3월 7일</summary>
<div markdown="1">

### 머클루트(Merkle Root)란?
- 블록체인의 원소 역할을 수행하는 블록의 부분에 저장된 트랜잭션들의 해시트리이다.
- 각각의 블록 안에는 여러 개의 트랜잭션들이 담겨져 있는데, 해당 정보들은 SHA-256로 해싱되어 저장되고 해시화 된 거래 정보들은 최신순으로 2개씩 짝을 지어 해쉬값을 결합해 새로운 한 쌍의 해쉬값으로 상위에 저장된다. 이 과정이 반복되면 최상위에 한 개의 해쉬 값이 구해지게 되는데 이를 '머클루트'라고 한다.

</div>
</details>

<details>
<summary>3월 10일</summary>
<div markdown="1">

# 스트리밍 집계 스마트 컨트랙트의 이벤트를 얼마나 쪼개야 할까?

### 배경

각각의 집계 기준마다 이벤트를 정의하면 해당 집계 기준에 따른 이벤트 로그 인덱싱이 가능하다.

이 집계 기준을 세세하게 쪼개면 이벤트 로그가 많이 발생할 것이고, 반면 집계 기준을 전체와 사용자 별로만 크게 나누면 IPFS에서 데이터를 불러온 이후 추가적인 필터링 과정이 필요하다.

### 집계 데이터를 어디서 이용하는데?

우리의 스트리밍 데이터는 차트, 사용자의 대시보드, 정산 내역 등 비교적 빠른 응답이 필요한 기능에서 사용된다.

가스 비용이 비교적 많이 발생하더라도 빠른 조회가 가능한 집계 기준 별 세세한 이벤트 정의를 하는 것이 좋다. → TheGraph를 이용한 인덱싱으로 빠른 조회 가능 및 IPFS에서 데이터 조회 이후 추가적인 필터링 불필요

</div>
</details>

<details>
<summary>3월 11일</summary>
<div markdown="1">

# 스트리밍 집계 스마트 컨트랙트 이벤트 정의

### 이벤트 설계 방안

- 스마트 컨트랙트에 절차를 담는 것이 아닌 어떤 집계 방식인지에 대한 즉, 인덱싱을 위한 이벤트 설계를 해야 한다.

### 1.  전체 스트리밍

- **이벤트 구조**
    
    ```solidity
    event RawAllTracksUpdated(
        uint256 indexed batchTimestamp,
        string cid
    );
    ```
    
- **IPFS 데이터 구조**
    
    ```json
    {
      "aggregationPeriod": {
        "start": "2025-03-10T00:00:00Z",
        "end": "2025-03-10T01:00:00Z"
      },
      "logs": [
        {
          "timestamp": "2025-03-10T00:05:00Z",
          "userId": "0x1234...abcd",
          "trackId": "track1",
          "albumId": "album1",
          "genreId": "rock"
        },
        {
          "timestamp": "2025-03-10T00:06:00Z",
          "userId": "0x5678...efgh",
          "trackId": "track1",
          "albumId": "album1",
          "genreId": "rock"
        }
        // ... 해당 배치 동안 발생한 모든 개별 스트리밍 로그
      ],
      "aggregatedData": {
        "tracks": [
          {
            "trackId": "track1",
            "streamCount": 1200
          },
          {
            "trackId": "track2",
            "streamCount": 1150
          }
          // ... 상위 20개 트랙에 대한 집계 데이터
        ],
        "albums": [
          {
            "albumId": "album1",
            "streamCount": 2500
          },
          {
            "albumId": "album2",
            "streamCount": 2300
          }
          // ... 상위 20개 앨범에 대한 집계 데이터
        ]
      }
    }
    ```
    
- **활용 기능**
    - 전체 Hot20 트랙
    - 전체 Hot20 앨범

### 2.  장르 별 스트리밍

- **이벤트 구조**
    
    ```solidity
    event RawGenreTracksUpdated(
        uint256 indexed batchTimestamp,
        bytes32 indexed genreId,
        string cid
    );
    ```
    
- **IPFS 데이터 구조**
    
    ```json
    {
      "aggregationPeriod": {
        "start": "2025-03-10T00:00:00Z",
        "end": "2025-03-10T01:00:00Z"
      },
      "genreId": "rock",
      "logs": [
        {
          "timestamp": "2025-03-10T00:05:00Z",
          "userId": "0x1234...abcd",
          "trackId": "track1",
          "albumId": "album1",
          "genreId": "rock"
        },
        {
          "timestamp": "2025-03-10T00:06:00Z",
          "userId": "0x5678...efgh",
          "trackId": "track1",
          "albumId": "album1",
          "genreId": "rock"
        }
        // ... 해당 배치 동안 발생한 모든 개별 스트리밍 로그
      ],
      "aggregatedData": {
        "tracks": [
          {
            "trackId": "track1",
            "streamCount": 1200
          },
          {
            "trackId": "track2",
            "streamCount": 1150
          }
          // ... 상위 20개 트랙에 대한 집계 데이터
        ],
        "albums": [
          {
            "albumId": "album1",
            "streamCount": 2500
          },
          {
            "albumId": "album2",
            "streamCount": 2300
          }
          // ... 상위 20개 앨범에 대한 집계 데이터
        ]
      }
    }
    ```
    
- **활용 기능**
    - 장르별 Hot20 트랙
    - 장르별 Hot20 앨범

### 3.  아티스트 별 스트리밍

- **이벤트 구조**
    
    ```solidity
    event RawGenreTracksUpdated(
        uint256 indexed batchTimestamp,
        bytes32 indexed artistId,
        string cid
    );
    ```
    
- **IPFS 데이터 구조**
    
    ```json
    {
      "aggregationPeriod": { "start": "2025-03-10T00:00:00Z", "end": "2025-03-10T01:00:00Z" },
      "artistId": "0x1234...abcd",
      "logs": [ ... ], // ... 해당 배치 동안 발생한 모든 개별 스트리밍 로그
      "aggregatedData": {
        "tracks": {
          "track1": 1200,
          "track2": 1150
          // ... 전체 트랙에 대한 집계 데이터
          // ... 각 트랙 ID를 키로, 스트림 수를 값으로 저장
        },
        "albums": {
          "album1": 2500,
          "album2": 2300
           // ... 전체 앨범에 대한 집계 데이터
        }
      }
    }
    
    ```
    
- **활용 기능**
    - 나의 트랙 별 누적 스트리밍 수
    - 나의 앨범 별 누적 스트리밍 수
    - 이번 달 나의 트랙들의 총 합산 스트리밍 수

### 4.  리스너 별 스트리밍

- **이벤트 구조**
    
    ```solidity
    event RawGenreTracksUpdated(
        uint256 indexed batchTimestamp,
        bytes32 indexed listenerId,
        string cid
    );
    ```
    
- **IPFS 데이터 구조**
    
    ```json
    {
      "aggregationPeriod": {
        "start": "2025-03-01T00:00:00Z",
        "end": "2025-03-31T23:59:59Z"
      },
      "listenerId": "0xABCDEF1234567890",
      "aggregatedData": {
        "0xArtist1": {
          "totalStreams": 1000,
          "tracks": {
            "trackA": 300,
            "trackB": 700
          },
          "logs": [
            {
              "timestamp": "2025-03-10T00:05:00Z",
              "trackId": "trackA",
              "albumId": "album1"
            },
            {
              "timestamp": "2025-03-10T00:07:00Z",
              "trackId": "trackB",
              "albumId": "album1"
            }
            // ... 해당 아티스트의 각 스트리밍 이벤트 기록
          ]
        },
        "0xArtist2": {
          "totalStreams": 500,
          "tracks": {
            "trackC": 250,
            "trackD": 250
          },
          "logs": [
            {
              "timestamp": "2025-03-10T01:05:00Z",
              "trackId": "trackC",
              "albumId": "album2"
            },
            {
              "timestamp": "2025-03-10T01:07:00Z",
              "trackId": "trackD",
              "albumId": "album2"
            }
            // ... 해당 아티스트의 스트리밍 로그
          ]
        }
        // ... 추가 아티스트 데이터
      }
    }
    
    ```
    
- **활용 기능**
    - 이번 달 내가 들은 총 스트리밍 수의 아티스트 별 비율
    - 이번 달 내가 들은 특정 아티스트의 트랙 별 스트리밍 이력

</div>
</details>

<details>
<summary>3월 12일</summary>
<div markdown="1">

# 체인링크를 사용해야 하는 이유

### 블록 체인은 외부 요소와 소통할 수 없다.

블록 체인 내부에서는 특정한 시간, 날씨, 가격 정보 등에 접근할 수 없다.

즉, 특정 시간이 되면 자동적으로 함수를 호출하는 등의 동작을 스스로 할 수 없다.

이 때, 필요한 것이 오라클 서비스이다. (대표적으로 체인링크)
오라클 서비스를 통해 특정한 조건이 되었을 때 스마트 컨트랙트의 함수를 호출하게 하여, 특정 조건 시의 동작을 구현할 수 있게 된다.

### 우리의 서비스는 어떠할까?

우리의 서비스에서 외부 요인이 조건이 되어 실행되어야 하는 요소들은 다음과 같다.

1. **결제 시간이 되면 자동으로 결제 처리**
2. **구독 기간이 끝나면 자동으로 정산 처리**

이 둘 모두 특정 시간을 조건으로 스마트 컨트랙트의 함수를 호출해 처리해야 하는 로직이다.

결국, 결제 스마트 컨트랙트와 구독-정산 스마트 컨트랙트 모두에 체인링크를 연결하는 것이 필요하다.

### 그렇다면 어떻게 사용할까?

자동화가 필요한 스마트 컨트랙트는 두 가지 필수 함수의 구현이 필요하다.

1. **checkUpKeep**
    
    계약의 현재 상태를 평가해 작업이 필요한지를 반환하며, 이 반환값에는 작업 필요 여부와 트랜잭션 시 필요한 인자가 담긴다.
    
2. **performUpKeep**
    
    checkUpKeep이 true를 반환하면, Keeper 노드 중 하나가 이 함수를 호출하여 실제 작업(구독 갱신, 정산 등)을 처리한다.
    

해당 작업들은 Keeper 네트워크 상의 여러 노드를 통해 주기적으로 이루어진다. 이 때엔 LINK 토큰 등의 보상을 노드에 주어 주어야 한다.

</div>
</details>

<details>
<summary>3월 13일</summary>
<div markdown="1">

# 비관리형 지갑에서 자동 결제를 구현하는 방법

### 비관리형 지갑을 사용하려는 이유

MetaMask 등의 비관리형 지갑을 사용하면 서버가 사용자의 지갑 주소를 관리할 필요 없이 송금 과정이 이루어진다. 서버는 단지 에스크로 주소를 제공할 뿐이다.
이렇게 함으로써, 서버가 결제 과정에 개입하지 않는 투명한 결제 방식을 구현할 수 있다.

### 어떻게 자동 결제를 구현할 수 있을까?

사용자가 매번 직접 에스크로에 송금하지 않고 자동으로 구독 갱신일마다 결제가 이루어지게 하려면 어떻게 해야 할까?

1. **ERC-20의 approve/transferFrom 메커니즘**
    
    폴리곤은 ERC-20 표준을 따르므로, approve와 transferFrom 함수를 사용할 수 있다. 
    approve를 통해 자신의 토큰을 사용할 수 있는 권한을 부여할 한도를 설정할 수 있고, 정해진 주기마다 transerFrom을 통해 사용자의 토큰을 인출할 수 있다.
    
2. **오라클 서비스 Chainlink Automation 활용**
    
    Chainlink Automation은 일정 주기마다 결제 시간에 도달한 사용자들을 체크업한다. 이후 해당 체크업 결과로 추려진 사용자들에 대해 실제 결제를 실행한다.

</div>
</details>
