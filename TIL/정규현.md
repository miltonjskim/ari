## 목차
- [Week 1 (2025-03-03 ~ 2025-03-07)](#week-1-2025-03-03---2025-03-07)
- [Week 2 (2025-03-10 ~ 2025-03-14)](#week-2-2025-03-10---2025-03-14)

---

## Week 1 (2025-03-03 ~ 2025-03-07)

<details>
  <summary>2025-03-04 TIL</summary>

### OOP의 안티 패턴
**1.스마트 UI**  
- 컨트롤러 레이어의 코드에서 모든 로직을 처리하는 형태.
- 컨트롤러가 제어, 비즈니스 로직, 영속성 관리 등 모든 일을 처리
- 이는 피해하는 안티 패턴 

**2.양방향 레이어드 아키텍처**
- 레이어드 아키텍처 하에서 상위 레이어는 하위 레이어에 의존 -> 역전되서는 X
- 즉, 레이어드 아키텍처 구현 시 레이어의 의존 방향은 단방향을 유지해야함.
- Controller단에서 사용한 Request Dto는 다시 사용되서는 X.
- 이를 위해 Controller에서 받은 Request Dto는 Command 형태로 변환되서 Service 단으로 전송되어야 함.

**3.트랜잭션 스크립트**
- 서비스 레이어의 클래스가 트랜잭션을 동작시키 듯 저장소에서 데이터를 가져와 연산 처리 및 저장하는 안티 패턴의 형태 
- 비지니스 로직은 도메인 모델에 담겨야 함. 
- 이를 통해 Service 레이어는 도메인 객체들을 불러 오고, 이들이 협력할 수 있는 공간을 주는 정도에 그쳐야 함. 

### 

</details>

<details>
  <summary>2025-03-05 TIL</summary>

### 블록체인의 트랜잭션

- 외부 소유 계정(EOA)에 의해 서명된 메시지
- 이더리움 네트워크에 전송되고 블록체인에 기록된다.
- 블록체인 상태 변경을 유발하거나 컨트랙트를 실행하는 유일한 방법
- 이더리움은 독자적으로 상태가 변경되지 않고
- 컨트랙트는 독자적으로 실행되지 않는다.

### 

</details>

<details>
  <summary>2025-03-06 TIL</summary>

## N:M 관계 테이블 설계

  1. 복합 키를 사용하는 방식
    - 두 개의 외래 키를 기본 키(PK) 로 사용하여 중복을 방지함.
      단순한 관계 매핑에 적합.

  2. 단일 기본 키를 사용하는 방식 (Surrogate Key 방식)
    - 관계 테이블에서 별도의 자동 증가 PK 를 추가하고, 두 개의 외래 키를 따로 설정.
      두 개의 외래키 조합을 유니크 제약 조건으로 설정하여 중복 방지 가능.
     확장성이 뛰어나고 추가적인 속성(예: 생성일, 상태 값 등) 저장이 필요할 때 유리함.

  ### 어떤 경우에 복합 키를 사용할까?

  1. 관계 자체가 단순한 경우 (단순한 N:M 매핑)

    - 중간 테이블에 추가적인 정보가 필요 없고, 그냥 연결 역할만 할 때 복합 키 사용이 적합.
      예: 학생(Student) - 강의(Course) 관계에서, 단순한 수강 관계라면 복합 키 사용 가능.
      성능을 고려해야 하는 경우

  2. 성능을 고려해야 하는 경우

    - 복합 키를 사용하면 불필요한 인덱스를 줄일 수 있어 조회 성능이 약간 더 좋을 수도 있음.
      하지만 이는 데이터량과 쿼리 패턴에 따라 다름.

  ### 언제 단일 기본 키(Surrogate Key)를 사용할까?
    
  1. 관계 테이블에 추가적인 속성이 필요한 경우

    - 중간 테이블에 created_at, status, role 등의 추가적인 필드가 필요할 경우.
      예: 사용자(User) - 그룹(Group) 관계에서, 그룹 내에서 역할(관리자/멤버)이 필요한 경우.

  2. JPA를 사용할 때 관리가 쉬운 경우

    - JPA에서 복합 키는 @IdClass 또는 @EmbeddedId 를 사용해야 하고, 구현이 복잡해질 수 있음.
      단일 기본 키를 사용하면 @ManyToOne 관계로 쉽게 매핑 가능.

### 

</details>

<details>
  <summary>2025-03-07 TIL </summary>

### Smart Contract

- 디지털 형식으로 명시된 서약들의 집합

### 블록체인에서의 정의

- 불변의 컴퓨터 프로그램 → 마스터링 이더리움
- 불변, 한 번 배포되면 변경 불가
- 결정적, 실행한 결과가 모두 같음
- EVM 위에서 동작 (ethereum virtual machine)
- 탈중앙화된 World Computer 동일한 상태를 유지

### Smart Contract를 작성하는 언어 (이더리움)

- Solidity(주로 사용)
- LLL
- Viper
- Assembly

### Smart Contract 배포와 호출

기억해야될 용어

- bytecode : 내가 작성한 Smart Contract Code에 컴파일된 코드
- ABI (Application Binary Interface) : 컨트랙트 안에 정의되어 있는 function의 리스트
- CA : 컨트랙트 배포 후 쓰게 될 주소

</details>
## Week 2 (2025-03-10 ~ 2025-03-14)
<details>
  <summary>2025-03-10 TIL </summary>
# 이더리움 Layer2 폴리곤을 활용한 스트리밍 데이터 온체인 로직

## 개요
이 프로젝트는 **Polygon Layer2**를 활용하여 **음악 스트리밍 데이터를 온체인에 기록하고 검증**하는 방식을 설계합니다.  
Merkle Tree를 사용하여 데이터를 요약하고, IPFS를 통해 원본 데이터를 저장하며, Web3j와 Spring Boot를 활용하여 백엔드에서 트랜잭션을 관리합니다.

---

## 아키텍처 개요
1. **오프체인 데이터 수집 및 집계**
2. **Merkle Tree를 활용한 데이터 요약**
3. **온체인 커밋 (스마트 컨트랙트 활용)**
4. **IPFS에 데이터 저장 및 검증**
5. **Polygon 네트워크를 통한 가스비 절감 및 확장성 확보**

---

## 1. 오프체인 데이터 수집 및 설계
### 실시간 이벤트 수집
- 스트리밍 이벤트(사용자 ID, 곡 ID, 타임스탬프, 스트리밍 시간 등)를 오프체인 데이터베이스 또는 Kafka, NoSQL 등에서 저장

### 주기적 데이터 집계
- 개별 이벤트마다 온체인 기록을 하지 않고, 일정 시간 동안 **사용자별, 곡별 집계 데이터**를 생성하여 기록

---

## 2. Merkle Tree를 활용한 데이터 요약
### Merkle Tree 구성
- 집계된 데이터를 각각의 **리프 노드**로 구성하여 Merkle Tree 생성
- 각 리프에는 사용자, 곡, 스트리밍 횟수, 집계 시간 등의 해시값 저장

### Merkle Root 산출
- 모든 리프 노드를 합산하여 최종 Merkle Root 생성
- 특정 기간 동안의 모든 스트리밍 데이터를 대표하는 **암호학적 요약 정보** 생성

---

## 3. 온체인 커밋
### 커밋 트랜잭션
- **Merkle Root**와 IPFS CID를 스마트 컨트랙트에 기록하여 데이터의 불변성을 보장

### 스마트 컨트랙트 활용
- **Merkle Root**, **집계 기간**, **IPFS CID** 등의 메타데이터를 온체인 저장하여 검증 가능하도록 처리

---

## 4. 데이터 저장 및 검증
### 오프체인 상세 데이터 저장
- 원본 스트리밍 데이터는 **IPFS** 또는 **Pinning 서비스(Infura IPFS 등)** 를 활용하여 저장
- 저장된 데이터의 **CID(Content Identifier)** 를 스마트 컨트랙트에 기록

### 데이터 검증
- 온체인에 저장된 Merkle Root를 통해 집계된 데이터의 무결성 검증 가능

---

## 5. 추가 고려사항 및 대안 네트워크
### 가스비 절감
- **Polygon Layer2**를 활용하여 **온체인 트랜잭션 수를 줄이고 비용을 절감**

### 대안 네트워크
- **테스트넷**: Goerli, Sepolia 사용 가능  
- **클라이언트 옵션**:
  - Geth: 가장 널리 사용됨 (GO언어 기반)
  - Besu: **Java 기반**, Spring과 친화적
  - Nethermind: 빠른 응답 속도 (.NET 기반)

---

## 기술 스택 및 구현
### **Web3j를 활용한 Spring Boot 연동**
- 스마트 컨트랙트 배포, 트랜잭션 관리, 이벤트 모니터링 지원
- Polygon RPC 엔드포인트 설정

</details>
